# main.py ‚Äî Portal SimonSports ‚Äî Orquestrador do bot com keepalive opcional
# - Executa bot.py de forma peri√≥dica
# - Mant√©m endpoint HTTP para Render/Replit quando ENABLE_KEEPALIVE=true

import os
import sys
import time
import signal
import threading
import subprocess

try:
    from flask import Flask
except Exception:
    # Flask s√≥ √© necess√°rio se ENABLE_KEEPALIVE=true
    Flask = None

# ===== Env (.env √© opcional) =====
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

ENABLE_KEEPALIVE = (os.getenv("ENABLE_KEEPALIVE", "false").strip().lower() == "true")
PORT = int(os.getenv("PORT", os.getenv("KEEPALIVE_PORT", "8080")))
RUN_EVERY_MINUTES = float(os.getenv("RUN_EVERY_MINUTES", "10"))  # intervalo entre execu√ß√µes
RUN_ONCE = (os.getenv("RUN_ONCE", "false").strip().lower() == "true")

# ===== App Flask (somente se manter vivo estiver habilitado) =====
app = Flask(__name__) if (ENABLE_KEEPALIVE and Flask) else None

if app:
    @app.get("/")
    @app.get("/ping")
    @app.get("/health")
    def home():
        return "‚úÖ Portal SimonSports ‚Äî Bot de Loterias ativo!", 200

# ===== Runner =====
def executar_bot_loop():
    """Roda o bot uma vez ou em loop, conforme RUN_ONCE/RUN_EVERY_MINUTES."""
    while True:
        try:
            print("üöÄ Executando bot.py ...", flush=True)
            # usa o mesmo interpretador em uso
            subprocess.run([sys.executable, "bot.py"], check=True)
        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è  bot.py terminou com c√≥digo {e.returncode}", flush=True)
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao executar bot.py: {e}", flush=True)

        if RUN_ONCE:
            print("üõë RUN_ONCE=true ‚Äî encerrando ap√≥s esta execu√ß√£o.", flush=True)
            break

        print(f"üïí Pr√≥xima execu√ß√£o em {RUN_EVERY_MINUTES} minuto(s)...", flush=True)
        time.sleep(max(1, int(RUN_EVERY_MINUTES * 60)))

def _on_sigterm(signum, frame):
    print("üîö SIGTERM recebido ‚Äî finalizando main.py.", flush=True)
    sys.exit(0)

# ===== Main =====
if __name__ == "__main__":
    signal.signal(signal.SIGTERM, _on_sigterm)

    # Quando h√° keepalive, o loop do bot roda em thread daemon; o Flask fica em foreground.
    # Sem keepalive, o loop fica em foreground (t.join()).
    t = threading.Thread(target=executar_bot_loop, daemon=ENABLE_KEEPALIVE)
    t.start()

    if ENABLE_KEEPALIVE and app:
        print(f"üåê Keepalive ON ‚Äî servindo em 0.0.0.0:{PORT}", flush=True)
        app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)
    else:
        print("üåê Keepalive OFF ‚Äî executando somente o loop do bot.", flush=True)
        t.join()